<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Combinat.jl</title><meta name="title" content="Home · Combinat.jl"/><meta property="og:title" content="Home · Combinat.jl"/><meta property="twitter:title" content="Home · Combinat.jl"/><meta name="description" content="Documentation for Combinat.jl."/><meta property="og:description" content="Documentation for Combinat.jl."/><meta property="twitter:description" content="Documentation for Combinat.jl."/><meta property="og:url" content="https://jmichel7.github.io/Combinat.jl/"/><meta property="twitter:url" content="https://jmichel7.github.io/Combinat.jl/"/><link rel="canonical" href="https://jmichel7.github.io/Combinat.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Combinat.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/Combinat.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/Combinat.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Combinat"><a class="docs-heading-anchor" href="#Combinat">Combinat</a><a id="Combinat-1"></a><a class="docs-heading-anchor-permalink" href="#Combinat" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jmichel7/Combinat.jl">Combinat</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.Combinat" href="#Combinat.Combinat"><code>Combinat.Combinat</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This  module  started  as  a  Julia  port of combinatorics and basic number theory  functions  from  GAP.  See  comments  below  on  how it compares to <code>Combinatorics.jl</code>. The only dependency is the <code>Primes</code> package.</p><p>The list of functions it exports are:</p><p>Classical enumerations:</p><p><a href="#Combinat.combinations"><code>combinations</code></a>, <a href="#Combinat.arrangements"><code>arrangements</code></a>, <a href="#Combinat.permutations"><code>permutations</code></a>, <a href="#Combinat.partitions"><code>partitions</code></a>, <a href="#Combinat.compositions"><code>compositions</code></a>, <a href="#Combinat.partition_tuples"><code>partition_tuples</code></a>, <a href="#Combinat.multisets"><code>multisets</code></a></p><p>the  first five of them  are implemented by iterators,  which have the same name but capitalized. This allows to do itemwise computations on very large enumerations without allocating memory:</p><p><a href="#Combinat.Combinations"><code>Combinations</code></a>, <a href="#Combinat.Arrangements"><code>Arrangements</code></a>, <a href="#Combinat.Permutations"><code>Permutations</code></a>, <a href="#Combinat.Partitions"><code>Partitions</code></a>, <a href="#Combinat.Compositions"><code>Compositions</code></a>,</p><p>functions to count enumerations without computing them:</p><p><code>ncombinations</code>, <code>narrangements</code>, <code>npermutations</code>, <code>npartitions</code>, <code>npartition_tuples</code>, <code>ncompositions</code>, <code>nmultisets</code></p><p>some functions on partitions and tableaux:</p><p><a href="#Combinat.lcm_partitions"><code>lcm_partitions</code></a>, <a href="#Combinat.gcd_partitions"><code>gcd_partitions</code></a>, <a href="#Combinat.conjugate_partition"><code>conjugate_partition</code></a>, <a href="#Combinat.dominates"><code>dominates</code></a>, <a href="#Combinat.tableaux"><code>tableaux</code></a>, <a href="#Combinat.semistandard_tableaux"><code>semistandard_tableaux</code></a>, <a href="#Combinat.robinson_schensted"><code>robinson_schensted</code></a></p><p>counting functions:</p><p><a href="#Combinat.bell"><code>bell</code></a>, <a href="#Combinat.stirling1"><code>stirling1</code></a>, <a href="#Combinat.stirling2"><code>stirling2</code></a>, <a href="#Combinat.catalan-Tuple{Integer}"><code>catalan</code></a>, <a href="#Combinat.bernoulli"><code>bernoulli</code></a></p><p>number theory</p><p><a href="#Combinat.prime_residues"><code>prime_residues</code></a>, <a href="#Combinat.primitiveroot"><code>primitiveroot</code></a>, <a href="#Combinat.moebius"><code>moebius</code></a></p><p>some structural manipulations not (yet?) in Julia:</p><p><a href="#Combinat.groupby"><code>groupby</code></a>, <a href="#Combinat.tally"><code>tally</code></a>, <a href="#Combinat.tally_sorted"><code>tally_sorted</code></a>, <a href="#Combinat.collectby"><code>collectby</code></a>, <a href="#Combinat.unique_sorted!"><code>unique_sorted!</code></a>, <a href="#Combinat.union_sorted"><code>union_sorted</code></a>, <a href="#Combinat.intersect_sorted"><code>intersect_sorted</code></a>, <a href="#Combinat.symdiff_sorted"><code>symdiff_sorted</code></a></p><p>matrix blocks:</p><p><a href="#Combinat.blocks-Tuple{AbstractMatrix}"><code>blocks</code></a>, <a href="#Combinat.diagblocks"><code>diagblocks</code></a></p><p>Have  a  look  at  the  individual  docstrings  and  enjoy (any feedback is welcome).  </p><p>After  writing  most  of  this  module,  I  became  aware  of  the  package <code>Combinatorics</code>  which has a  considerable overlap. However  there are some discrepancies  between these  two packages  which make  <code>Combinatorics</code> not a suitable replacement:</p><ul><li><p>I often  use sorting  in algorithms  where <code>Combinatorics</code> uses hashing. So  the algorithms do  not always apply  to the same  types (sorting is often  faster). For  some algorithms,  I have  a keyword which lets you choose  a hashing variant. Here  hashable refers to a  type which has a <code>hash</code> method and sortable to a type which has an <code>isless</code> method.</p></li><li><p><code>Combinatorics.combinations</code> does not include the empty subset.</p></li><li><p>I use lower  case for functions  that return enumerations  as a list and camel  case  for  iterators.  Many  enumerations  have  both  variants. <code>Combinatorics</code> has only one variant for enumerations, which is often a lowercase iterator.</p></li><li><p><code>Combinatorics</code> has fewer enumerations.</p></li></ul><p>A    less   fundamental   discrepancy   concerns   names.   For   instance, <code>Combinatorics.multiset_combinations</code>   and   <code>Combinatorics.powerset</code>  are cases   of  <code>Combinat.combinations</code>;  <code>Combinatorics.multiexponents</code>  is  a special case of <code>Combinat.compositions</code>; <code>Combinatorics.integer_partitions</code> is  a case  of <code>Combinat.partitions</code>; <code>Combinatorics.multiset_permutations</code> is <code>Combinat.arrangements</code>. I would welcome discussions with the authors of <code>Combinatorics</code> to see if the two packages could be made more compatible in this respect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.combinations" href="#Combinat.combinations"><code>Combinat.combinations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>combinations(mset[,k];dict=false)</code>,  <code>ncombinations(mset[,k];dict=false)</code></p><p><code>combinations</code>   returns  all  combinations  of   the  multiset  <code>mset</code>  (a collection  or  iterable  with  possible  repetitions). If a second integer argument  <code>k</code> is given, it returns  the combinations with <code>k</code> elements. <code>k</code> may  also be a vector  of integers, then it  returns the combinations whose number of elements is one of these integers.</p><p><code>ncombinations</code> returns (faster) the number of combinations.</p><p>A  <em>combination</em> is an unordered subsequence.</p><p>By  default, the elements of <code>mset</code>  are assumed sortable and a combination is  represented by a sorted <code>Vector</code>.  The combinations with a fixed number <code>k</code>  of  elements  are  listed  in  lexicographic order. If the elements of <code>mset</code>  are not sortable but hashable, the keyword <code>dict=true</code> can be given and the (slightly slower) computation is done using a <code>Dict</code>.</p><p>If  <code>mset</code> has  no repetitions,  the list  of all  combinations is just the <em>powerset</em> of <code>mset</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ncombinations([1,2,2,3])
12

julia&gt; combinations([1,2,2,3])
12-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [1, 2]
 [1, 3]
 [2, 2]
 [2, 3]
 [1, 2, 2]
 [1, 2, 3]
 [2, 2, 3]
 [1, 2, 2, 3]</code></pre><p>The  combinations  are  implemented  by  an iterator <a href="#Combinat.Combinations"><code>Combinations</code></a> which can enumerate the combinations of a large multiset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L512-L555">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.Combinations" href="#Combinat.Combinations"><code>Combinat.Combinations</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Combinations(s[,k];dict=false)</code>  is an  iterator which enumerates the  combinations of  the multiset  <code>s</code> (with  <code>k</code> elements if <code>k</code>given) in lexicographic order. The elements of <code>s</code> must be sortable. If they are not, but  hashable, giving the  keyword <code>dict=true</code> will  give an iterator which enumerates the combinations in an unspecified order.</p><pre><code class="language-julia-repl hljs">julia&gt; a=Combinations(1:4);

julia&gt; collect(a)
16-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [4]
 [1, 2]
 [1, 3]
 [1, 4]
 [2, 3]
 [2, 4]
 [3, 4]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [2, 3, 4]
 [1, 2, 3, 4]

julia&gt; a=Combinations([1,2,2,3,4,4],3)
Combinations([1, 2, 2, 3, 4, 4],3)

julia&gt; collect(a)
10-element Vector{Vector{Int64}}:
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 4]
 [2, 4, 4]
 [3, 4, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L406-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.arrangements" href="#Combinat.arrangements"><code>Combinat.arrangements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>arrangements(mset[,k])</code>, <code>narrangements(mset[,k])</code></p><p><code>arrangements</code>  returns  the  arrangements  of  the  multiset <code>mset</code> (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument   <code>k</code>  is  given,  it  returns  arrangements  with  <code>k</code>  elements. <code>narrangements</code> returns (faster) the number of arrangements.</p><p>An <em>arrangement</em> of <code>mset</code> with <code>k</code> elements is a subsequence of length <code>k</code> taken in arbitrary order, representated as a <code>Vector</code>. When <code>k==length(mset)</code> it is also called a permutation.</p><p>As  an example of arrangements  of a multiset, think  of the game Scrabble. Suppose  you have the six  characters of the word  &#39;settle&#39; and you have to make a two letter word. Then the possibilities are given by</p><pre><code class="language-julia-repl hljs">julia&gt; narrangements(&quot;settle&quot;,2)
14</code></pre><p>while all possible words (including the empty one) are:</p><pre><code class="language-julia-repl hljs">julia&gt; narrangements(&quot;settle&quot;)
523</code></pre><p>Here are the two-letter words:</p><pre><code class="language-julia-repl hljs">julia&gt; String.(arrangements(&quot;settle&quot;,2))
14-element Vector{String}:
 &quot;ee&quot;
 &quot;el&quot;
 &quot;le&quot;
 &quot;es&quot;
 &quot;se&quot;
 &quot;et&quot;
 &quot;te&quot;
 &quot;ls&quot;
 &quot;sl&quot;
 &quot;lt&quot;
 &quot;tl&quot;
 &quot;st&quot;
 &quot;ts&quot;
 &quot;tt&quot;</code></pre><p>The  arrangements are implemented  by an iterator  <code>Arrangements</code> which can enumerate the arrangements of a large multiset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L671-L718">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.Arrangements" href="#Combinat.Arrangements"><code>Combinat.Arrangements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Arrangements</code> is an iterator for <code>arrangements</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.permutations" href="#Combinat.permutations"><code>Combinat.permutations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>permutations(v::AbstractVector)</code>, <code>permutations(n::Int)</code>, <code>npermutations</code></p><p>in  the first  form, the  elements of  <code>v</code> must  be sortable.  The function returns  in lexicographic  order the  distinct permutations  of the  set or multiset <code>v</code>.  This   is  the  same   as  <code>arrangements(v,length(v))</code>.  </p><p>The second form is the same as <code>permutations(1:n)</code>.</p><p><code>permutations</code> is implemented by an iterator <code>Permutations</code>.</p><p><code>npermutations</code> counts the permutations (fast) without computing them.</p><pre><code class="language-julia-repl hljs">julia&gt; permutations(3)
6-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 3, 2]
 [2, 1, 3]
 [2, 3, 1]
 [3, 1, 2]
 [3, 2, 1]

julia&gt; sum(first(p) for p in Permutations(5))
360

julia&gt; permutations([:b,:b,:a,:a])
6-element Vector{Vector{Symbol}}:
 [:a, :a, :b, :b]
 [:a, :b, :a, :b]
 [:a, :b, :b, :a]
 [:b, :a, :a, :b]
 [:b, :a, :b, :a]
 [:b, :b, :a, :a]
 
julia&gt; npermutations([:b,:b,:a,:a])
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L580-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.Permutations" href="#Combinat.Permutations"><code>Combinat.Permutations</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Permutations</code> is an iterator for <code>permutations</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.partitions" href="#Combinat.partitions"><code>Combinat.partitions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>partitions(n::Integer[,k])</code>, <code>npartitions(n::Integer[,k])</code></p><p><code>partitions</code>  returns in lexicographic order the partitions (with <code>k</code> parts if  <code>k</code>  is  given)  of  the  positive  integer <code>n</code> . <code>npartitions</code> returns (faster) the number of partitions.</p><p>There are approximately <code>exp(π√(2n/3))/(4√3 n)</code> partitions of <code>n</code>.</p><p>A   <em>partition</em>  is   a  decomposition   <code>n=p₁+p₂+…+pₖ</code>  in  integers  with <code>p₁≥p₂≥…≥pₖ&gt;0</code>, and is represented by the vector <code>p=[p₁,p₂,…,pₖ]</code>. We write <code>p⊢n</code> to say that <code>p</code> is a partition of <code>n</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; npartitions(7)
15

julia&gt; partitions(7)
15-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [2, 2, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [3, 2, 2]
 [3, 3, 1]
 [4, 1, 1, 1]
 [4, 2, 1]
 [4, 3]
 [5, 1, 1]
 [5, 2]
 [6, 1]
 [7]

julia&gt; npartitions(7,3)
4

julia&gt; partitions(7,3)
4-element Vector{Vector{Int64}}:
 [3, 2, 2]
 [3, 3, 1]
 [4, 2, 1]
 [5, 1, 1]</code></pre><p>The  partitions are implemented by an iterator <code>Partitions(n[,k])</code> which can be used to enumerate the partitions of a large number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L836-L884">source</a></section><section><div><p><code>partitions(n::Integer,set::AbstractVector[,k])</code>, <code>npartitions(n::Integer,set::AbstractVector[,k])</code>   </p><p>returns  the list  of partitions  of <code>n</code>  (with <code>k</code>  parts if <code>k</code> is given) restricted  to have parts in <code>set</code>. <code>npartitions</code> gives (faster) the number of such partitions.</p><p>Let  us show how many ways there are to pay 17 cents using coins of 2,5 and 10 cents.</p><pre><code class="language-julia-repl hljs">julia&gt; npartitions(17,[10,5,2])
3

julia&gt; partitions(17,[10,5,2])
3-element Vector{Vector{Int64}}:
 [5, 2, 2, 2, 2, 2, 2]
 [5, 5, 5, 2]
 [10, 5, 2]

julia&gt; npartitions(17,[10,5,2],3) # pay with 3 coins
1

julia&gt; partitions(17,[10,5,2],3) 
1-element Vector{Vector{Int64}}:
 [10, 5, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L918-L944">source</a></section><section><div><p><code>partitions(set::AbstractVector[,k])</code>, <code>npartitions(set::AbstractVector[,k])</code></p><p>the  set of all unordered  partitions (in <code>k</code> sets  if <code>k</code> is given) of the set  <code>set</code> (a  collection without  repetitions). <code>npartitions</code>  returns the number of unordered partitions.</p><p>An <em>unordered partition</em> of <code>set</code> is a set of pairwise disjoints sets whose union is equal to <code>set</code>, and is represented by a Vector of Vectors.</p><pre><code class="language-julia-repl hljs">julia&gt; npartitions(1:3)
5

julia&gt; partitions(1:3)
5-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 3]]
 [[1, 2], [3]]
 [[1, 3], [2]]
 [[1], [2, 3]]
 [[1], [2], [3]]

julia&gt; npartitions(1:4,2)
7

julia&gt; partitions(1:4,2)
7-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 3], [4]]
 [[1, 2, 4], [3]]
 [[1, 2], [3, 4]]
 [[1, 3, 4], [2]]
 [[1, 3], [2, 4]]
 [[1, 4], [2, 3]]
 [[1], [2, 3, 4]]</code></pre><p>Note  that <code>unique(sort.(partitions(mset[,k])))</code>  is a  version which works for a multiset <code>mset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1029-L1066">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.Partitions" href="#Combinat.Partitions"><code>Combinat.Partitions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Partitions(n[,k])</code> is an iterator which enumerates the partitions of <code>n</code> (with <code>k</code> parts if <code>k</code>given) in lexicographic order.</p><pre><code class="language-julia-repl hljs">julia&gt; a=Partitions(5)
Partitions(5)

julia&gt; collect(a)
7-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1]
 [2, 1, 1, 1]
 [2, 2, 1]
 [3, 1, 1]
 [3, 2]
 [4, 1]
 [5]

julia&gt; a=Partitions(10,3)
Partitions(10,3)

julia&gt; collect(a)
8-element Vector{Vector{Int64}}:
 [4, 3, 3]
 [4, 4, 2]
 [5, 3, 2]
 [5, 4, 1]
 [6, 2, 2]
 [6, 3, 1]
 [7, 2, 1]
 [8, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L746-L777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.partition_tuples" href="#Combinat.partition_tuples"><code>Combinat.partition_tuples</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>partition_tuples(n,r)</code>, <code>npartition_tuples(n,r)</code></p><p>the <code>r</code>-tuples of partitions that together partition <code>n</code>. <code>npartition_tuples</code> is the number of partition tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; npartition_tuples(3,2)
10

julia&gt; partition_tuples(3,2)
10-element Vector{Vector{Vector{Int64}}}:
 [[1, 1, 1], []]
 [[1, 1], [1]]
 [[1], [1, 1]]
 [[], [1, 1, 1]]
 [[2, 1], []]
 [[1], [2]]
 [[2], [1]]
 [[], [2, 1]]
 [[3], []]
 [[], [3]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1248-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.compositions" href="#Combinat.compositions"><code>Combinat.compositions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>compositions(n[,k];min=1)</code>, <code>ncompositions(n[,k];min=1)</code></p><p>This  function returns the compositions of  <code>n</code> (the compositions of length <code>k</code>  if a second argument <code>k</code> is given), where a composition of the integer <code>n</code>  is a decomposition <code>n=p₁+…+pₖ</code> in  integers <code>≥min</code>, represented as the vector  <code>[p₁,…,pₖ]</code>. Unless <code>k</code> is given,  <code>min</code> must be <code>&gt;0</code>. Compositions are sometimes called ordered partitions.</p><p><code>ncompositions</code>  returns  (faster)  the  number  of compositions. There are <span>$2^{n-1}$</span>  compositions of <code>n</code> in  integers <code>≥1</code>, and <code>binomial(n-1,k-1)</code> compositions of <code>n</code> in <code>k</code> parts <code>≥1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ncompositions(4)
8

julia&gt; compositions(4)
8-element Vector{Vector{Int64}}:
 [4]
 [1, 3]
 [2, 2]
 [3, 1]
 [1, 1, 2]
 [1, 2, 1]
 [2, 1, 1]
 [1, 1, 1, 1]

julia&gt; ncompositions(4,2)
3

julia&gt; compositions(4,2)
3-element Vector{Vector{Int64}}:
 [1, 3]
 [2, 2]
 [3, 1]

julia&gt; ncompositions(4,2;min=0)
5

julia&gt; compositions(4,2;min=0)
5-element Vector{Vector{Int64}}:
 [0, 4]
 [1, 3]
 [2, 2]
 [3, 1]
 [4, 0]</code></pre><p>The compositions are implemented by an iterator <code>Compositions(n[,k];min=1)</code> which can be used to enumerate the compositions of a large number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1352-L1402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.Compositions" href="#Combinat.Compositions"><code>Combinat.Compositions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Compositions</code> is an iterator for <code>compositions</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.multisets" href="#Combinat.multisets"><code>Combinat.multisets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>multisets(set,k)</code>, <code>nmultisets(set,k)</code></p><p><code>multisets</code>  returns  the  set  of  all  multisets of length <code>k</code> made of elements   of   the   set   <code>set</code>   (a   collection  without  repetitions). <code>nmultisets</code> returns the number of multisets.</p><p>An  <em>multiset</em> of length <code>k</code> is  an unordered selection with repetitions of length  <code>k</code> from <code>set</code> and is represented  by a sorted vector of length <code>k</code> made  of elements  from <code>set</code>  (it is  also sometimes called a &quot;combination with replacement&quot;).</p><pre><code class="language-julia-repl hljs">julia&gt; multisets(1:4,3)
20-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 1, 2]
 [1, 1, 3]
 [1, 1, 4]
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 3]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 2]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 3]
 [2, 3, 4]
 [2, 4, 4]
 [3, 3, 3]
 [3, 3, 4]
 [3, 4, 4]
 [4, 4, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1414-L1450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.lcm_partitions" href="#Combinat.lcm_partitions"><code>Combinat.lcm_partitions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>lcm_partitions(p1,…,pn)</code></p><p>each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p><p>The result is the finest partition of <code>S</code> such that each argument partition refines it. It represents the &#39;or&#39; of the equivalence relations represented by the arguments.</p><pre><code class="language-julia-repl hljs">julia&gt; lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
2-element Vector{Vector{Int64}}:
 [1, 2, 5, 6]
 [3, 4]      </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1519-L1536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.gcd_partitions" href="#Combinat.gcd_partitions"><code>Combinat.gcd_partitions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>gcd_partitions(p1,…,pn)</code></p><p>Each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p><p>The result is the coarsest partition which refines all argument partitions. It  represents the  &#39;and&#39; of  the equivalence  relations represented by the arguments.</p><pre><code class="language-julia-repl hljs">julia&gt; gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1552-L1573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.conjugate_partition" href="#Combinat.conjugate_partition"><code>Combinat.conjugate_partition</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>conjugate_partition(λ)</code></p><p>returns  the  conjugate  partition  of  the  partition  <code>λ</code>,  that  is, the partition having the transposed of the Young diagram of <code>λ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; conjugate_partition([4,2,1])
4-element Vector{Int64}:
 3
 2
 1
 1

julia&gt; conjugate_partition([6])
6-element Vector{Int64}:
 1
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1702-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.dominates" href="#Combinat.dominates"><code>Combinat.dominates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>dominates(λ,μ)</code></p><p>The  dominance  order  on  partitions  is  an  important  partial  order in representation theory. <code>λ</code> dominates <code>μ</code> if and only if for all <code>i</code> we have <code>sum(λ[1:i])≥sum(μ[1:i])</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dominates([5,4],[4,4,1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1732-L1743">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.tableaux" href="#Combinat.tableaux"><code>Combinat.tableaux</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>tableaux(S)</code></p><p>if  <code>S</code>  is  a  partition  tuple,  returns  the  list  of standard tableaux associated  with  the  partition  tuple  <code>S</code>,  that  is  a  filling  of the associated  young diagrams  with the  numbers <code>1:sum(sum,S)</code>  such that the numbers increase across the rows and down the columns.</p><p>If  <code>S</code> is a single partition, the standard tableaux for that partition are returned.</p><pre><code class="language-julia-repl hljs">julia&gt; tableaux([[2,1],[1]])
8-element Vector{Vector{Vector{Vector{Int64}}}}:
 [[[1, 2], [3]], [[4]]]
 [[[1, 2], [4]], [[3]]]
 [[[1, 3], [2]], [[4]]]
 [[[1, 3], [4]], [[2]]]
 [[[1, 4], [2]], [[3]]]
 [[[1, 4], [3]], [[2]]]
 [[[2, 3], [4]], [[1]]]
 [[[2, 4], [3]], [[1]]]

julia&gt; tableaux([2,2])
2-element Vector{Vector{Vector{Int64}}}:
 [[1, 2], [3, 4]]
 [[1, 3], [2, 4]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1752-L1780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.semistandard_tableaux" href="#Combinat.semistandard_tableaux"><code>Combinat.semistandard_tableaux</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>semistandard_tableaux(λ,c)</code></p><p><code>c</code>  should be  a non-decreasing  list and  <code>λ</code> a partition of <code>length(c)</code>. Returns  the list of semi_standard tableaux with shape <code>λ</code> and content <code>c</code>, that is a filling of the young diagram of <code>λ</code> with the elements of <code>c</code> such that they increase down the columns and do not decrease across the rows.</p><pre><code class="language-julia-repl hljs">julia&gt; semistandard_tableaux([3,2,1],[1,2,2,3,4,5])
8-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 2], [3, 4], [5]]
 [[1, 2, 2], [3, 5], [4]]
 [[1, 2, 3], [2, 4], [5]]
 [[1, 2, 3], [2, 5], [4]]
 [[1, 2, 4], [2, 3], [5]]
 [[1, 2, 5], [2, 3], [4]]
 [[1, 2, 4], [2, 5], [3]]
 [[1, 2, 5], [2, 4], [3]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1797-L1816">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.robinson_schensted" href="#Combinat.robinson_schensted"><code>Combinat.robinson_schensted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>robinson_schensted(p::AbstractVector{&lt;:Integer})</code></p><p>returns  the pair of standard tableaux  associated with the permutation <code>p</code> by the Robinson-Schensted correspondence.</p><pre><code class="language-julia-repl hljs">julia&gt; robinson_schensted([2,3,4,1])
([[1, 3, 4], [2]], [[1, 2, 3], [4]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1838-L1848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.bell" href="#Combinat.bell"><code>Combinat.bell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>&#39;bell(n)&#39;</p><p>The  Bell numbers are  defined by <code>bell(0)=1</code>  and <span>$bell(n+1)=∑_{k=0}^n {n \choose  k}bell(k)$</span>, or by the fact  that <code>bell(n)/n!</code> is the coefficient of <code>xⁿ</code> in the formal series <code>e^(eˣ-1)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; bell.(0:6)
7-element Vector{Int64}:
   1
   1
   2
   5
  15
  52
 203

julia&gt; bell(14)
190899322

julia&gt; bell(big(30))
846749014511809332450147</code></pre><p>Also, <code>bell(n)</code> is the number of unordered partitions of a set of size <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1187-L1212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.stirling1" href="#Combinat.stirling1"><code>Combinat.stirling1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>stirling1(n,k)</code></p><p>the  <em>Stirling  numbers  of  the  first  kind</em>  <code>S₁(n,k)</code>  are  defined  by <code>S₁(0,0)=1,   S₁(n,0)=S₁(0,k)=0</code>   if   <code>n,   k!=0</code>   and   the  recurrence <code>S₁(n,k)=(n-1)S₁(n-1,k)+S₁(n-1,k-1)</code>.</p><p><code>S₁(n,k)</code>  is the  number of  permutations of  <code>n</code> points  with <code>k</code> cycles. They   are   also   given   by   the   generating  function  <span>$n!{x\choose n}=\sum_{k=0}^n(S₁(n,k) x^k)$</span>. Note the similarity to <span>$x^n=\sum_{k=0}^n S₂(n,k)k!{x\choose k}$</span> (see  <code>stirling2</code>).  Also  the  definition of <code>S₁</code> implies  <code>S₁(n,k)=S₂(-k,-n)</code> if  <code>n,k&lt;0</code>. There  are many formulae relating Stirling  numbers of the first kind to Stirling numbers of the second kind, Bell numbers, and Binomial numbers.</p><pre><code class="language-julia-repl hljs">julia&gt; stirling1.(4,0:4) # Knuth calls this the trademark of S₁
5-element Vector{Int64}:
  0
  6
 11
  6
  1

julia&gt; [stirling1(n,k) for n in 0:6, k in 0:6] # similar to Pascal&#39;s triangle
7×7 Matrix{Int64}:
 1    0    0    0   0   0  0
 0    1    0    0   0   0  0
 0    1    1    0   0   0  0
 0    2    3    1   0   0  0
 0    6   11    6   1   0  0
 0   24   50   35  10   1  0
 0  120  274  225  85  15  1

julia&gt; stirling1(50,big(10)) # give `big` second argument to avoid overflow
101623020926367490059043797119309944043405505380503665627365376</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1086-L1123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.stirling2" href="#Combinat.stirling2"><code>Combinat.stirling2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>stirling2(n,k)</code></p><p>the  <em>Stirling  numbers  of  the  second  kind</em> are defined by <code>S₂(0,0)=1</code>, <code>S₂(n,0)=S₂(0,k)=0</code> if <code>n, k!=0</code> and <code>S₂(n,k)=k S₂(n-1,k)+S₂(n-1,k-1)</code>, and also as coefficients of the generating function <span>$x^n=\sum_{k=0}^{n}S₂(n,k) k!{x\choose k}$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; stirling2.(4,0:4)  # Knuth calls this the trademark of S₂
5-element Vector{Int64}:
 0
 1
 7
 6
 1

julia&gt; [stirling2(i,j) for i in 0:6, j in 0:6] # similar to Pascal&#39;s triangle
7×7 Matrix{Int64}:
 1  0   0   0   0   0  0 
 0  1   0   0   0   0  0
 0  1   1   0   0   0  0
 0  1   3   1   0   0  0
 0  1   7   6   1   0  0
 0  1  15  25  10   1  0
 0  1  31  90  65  15  1

julia&gt; stirling2(50,big(10)) # give `big` second argument to avoid overflow
26154716515862881292012777396577993781727011</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1139-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.catalan-Tuple{Integer}" href="#Combinat.catalan-Tuple{Integer}"><code>Combinat.catalan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Catalan(n)</code> <code>n</code>-th Catalan Number</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(8)
1430

julia&gt; catalan(big(50))
1978261657756160653623774456</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1581-L1591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.groupby" href="#Combinat.groupby"><code>Combinat.groupby</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>groupby(v,l)</code></p><p>return  a  <code>Dict</code>  grouping  elements  of  collection  <code>l</code> according to the corresponding  values in the collection <code>v</code>,  which should have same length as <code>l</code>, and whose elements must be hashable.</p><pre><code class="language-julia-rep1 hljs">julia&gt; groupby([31,28,31,30,31,30,31,31,30,31,30,31],
  [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])
Dict{Int64,Vector{Symbol}} with 3 entries:
  31 =&gt; Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]
  28 =&gt; Symbol[:Feb]
  30 =&gt; Symbol[:Apr, :Jun, :Sep, :Nov]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L124-L139">source</a></section><section><div><p><code>groupby(f::Function,l)</code></p><p>return a <code>Dict</code> grouping elements of collection <code>l</code> according to the values taken by function <code>f</code> on them. The values of <code>f</code> must be hashable.</p><pre><code class="language-julia-repl hljs">julia&gt; groupby(iseven,1:10)
Dict{Bool, Vector{Int64}} with 2 entries:
  0 =&gt; [1, 3, 5, 7, 9]
  1 =&gt; [2, 4, 6, 8, 10]</code></pre><p>Note:  keys of the result will  have type <code>Any</code> if <code>l</code>  is empty since I do not know how to access the return type of a function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L146-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.tally" href="#Combinat.tally"><code>Combinat.tally</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>tally(v;dict=false)</code></p><p>counts how many times each element of collection or iterable <code>v</code> occurs and returns a sorted <code>Vector</code> of <code>elt=&gt;count</code> (a variant of StatsBase.countmap).  By default the  elements of <code>v</code>  must be sortable; if they  are not but hashable, giving the keyword <code>dict=true</code> uses a <code>Dict</code> to build (much slower) an unsorted result.</p><pre><code class="language-julia-repl hljs">julia&gt; tally(&quot;a tally test&quot;)
7-element Vector{Pair{Char, Int64}}:
 &#39; &#39; =&gt; 2
 &#39;a&#39; =&gt; 2
 &#39;e&#39; =&gt; 1
 &#39;l&#39; =&gt; 2
 &#39;s&#39; =&gt; 1
 &#39;t&#39; =&gt; 3
 &#39;y&#39; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L170-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.tally_sorted" href="#Combinat.tally_sorted"><code>Combinat.tally_sorted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>tally_sorted(v)</code></p><p><code>tally_sorted</code>  is like <code>tally</code>  but works only  for a sorted iterable. The point is that it is very fast.</p><pre><code class="language-julia-repl hljs">julia&gt; tally_sorted(&quot;aabbbeee&quot;)
3-element Vector{Pair{Char, Int64}}:
 &#39;a&#39; =&gt; 2
 &#39;b&#39; =&gt; 3
 &#39;e&#39; =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.collectby" href="#Combinat.collectby"><code>Combinat.collectby</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>collectby(f,v)</code></p><p>group  the elements of <code>v</code> in packets  (<code>Vector</code>s) where <code>f</code> takes the same value.  The resulting <code>Vector{Vector}</code> is sorted  by the values of <code>f</code> (the values  of  <code>f</code>  must  be  sortable;  otherwise  you  can  use  the  slower <code>values(groupby(f,v))</code>).  Here <code>f</code> can  be a function  of one variable or a collection of same length as <code>v</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; l=[:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec];

julia&gt; collectby(x-&gt;first(string(x)),l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]

julia&gt; collectby(&quot;JFMAMJJASOND&quot;,l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L262-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.unique_sorted!" href="#Combinat.unique_sorted!"><code>Combinat.unique_sorted!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>unique_sorted!(v::Vector)</code> many times faster than unique! for sorted <code>v</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.intersect_sorted" href="#Combinat.intersect_sorted"><code>Combinat.intersect_sorted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>intersect_sorted(a,b)</code> </p><p>intersects   <code>a</code>  and   <code>b</code>  assumed   to  be   both  sorted   and  without repetitions(and  their elements sortable).  This is many  times faster than <code>intersect</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L321-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.symdiff_sorted" href="#Combinat.symdiff_sorted"><code>Combinat.symdiff_sorted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>symdiff_sorted(a,b)</code> </p><p>computes  the symmetric difference of <code>a</code> and <code>b</code> assumed to be both sorted and  without  repetitions  (and  their  elements  sortable).  The result is sorted,  so may differ  from <code>symdiff</code>; this  function is many times faster than <code>symdiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L375-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.union_sorted" href="#Combinat.union_sorted"><code>Combinat.union_sorted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>union_sorted(a,b)</code> </p><p>computes  the union of  <code>a</code> and <code>b</code>  assumed to be  both sorted and without repetitions  (and their  elements sortable).  The result  is sorted, so may differ from <code>union</code>; this function is many times faster than <code>union</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L347-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.diagblocks" href="#Combinat.diagblocks"><code>Combinat.diagblocks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>diagblocks(M::Matrix)</code></p><p><code>M</code>  should  be  a  square  matrix.  Define  a  graph  <code>G</code>  with vertices <code>1:size(M,1)</code> and with an edge between <code>i</code>  and <code>j</code> if either <code>M[i,j]</code> or <code>M[j,i]</code> is not zero or <code>false</code>. <code>diagblocks</code> returns a vector of vectors <code>I</code>  such that  <code>I[1]</code>,<code>I[2]</code>, etc..  are the  vertices in each connected component  of <code>G</code>.  In other  words, <code>M[I[1],I[1]]</code>,<code>M[I[2],I[2]]</code>,etc... are diagonal blocks of <code>M</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]
4×4 Matrix{Int64}:
 0  0  0  1
 0  0  1  0
 0  1  0  0
 1  0  0  0

julia&gt; diagblocks(m)
2-element Vector{Vector{Int64}}:
 [1, 4]
 [2, 3]

julia&gt; m[[1,4,2,3],[1,4,2,3]]
4×4 Matrix{Int64}:
 0  1  0  0
 1  0  0  0
 0  0  0  1
 0  0  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1594-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.blocks-Tuple{AbstractMatrix}" href="#Combinat.blocks-Tuple{AbstractMatrix}"><code>Combinat.blocks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>blocks(M:AbstractMatrix)</code></p><p>Finds  if the  matrix  <code>M</code> admits a block decomposition.</p><p>Define  a bipartite  graph <code>G</code>  with vertices  <code>axes(M,1)</code>, <code>axes(M,2)</code> and with an edge between <code>i</code> and <code>j</code> if <code>M[i,j]</code> is not zero. BlocksMat returns a  list of pairs of  lists <code>I</code> such that  <code>I[i]</code>, etc.. are the vertices in the <code>i</code>-th connected component of <code>G</code>. In other words, <code>M[I[1][1],I[1][2]], M[I[2][1],I[2][2]]</code>,etc... are blocks of <code>M</code>.</p><p>This  function may  also be  applied to  boolean matrices.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 0 0 0;0 1 0 0;1 0 1 0;0 0 0 1;0 0 1 0]
5×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 1  0  1  0
 0  0  0  1
 0  0  1  0

julia&gt; blocks(m)
3-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 3, 5], [1, 3])
 ([2], [2])
 ([4], [4])

julia&gt; m[[1,3,5,2,4],[1,3,2,4]]
5×4 Matrix{Int64}:
 1  0  0  0
 1  1  0  0
 0  1  0  0
 0  0  1  0
 0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1641-L1677">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.bernoulli" href="#Combinat.bernoulli"><code>Combinat.bernoulli</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>bernoulli(n)</code> the <code>n</code>-th <em>Bernoulli number</em>  <code>Bₙ</code> as a <code>Rational{BigInt}</code></p><p><code>Bₙ</code>    is    defined    by   <span>$B₀=1,   B_n=-\sum_{k=0}^{n-1}({n+1\choose k}B_k)/(n+1)$</span>.  <code>Bₙ/n!</code> is the coefficient of  <code>xⁿ</code> in the power series of <code>x/(eˣ-1)</code>.  Except for <code>B₁=-1/2</code> the Bernoulli numbers for odd indices are zero.</p><pre><code class="language-julia-repl hljs">julia&gt; bernoulli(4)
-1//30

julia&gt; bernoulli(10)
5//66

julia&gt; bernoulli(12) # there is no simple pattern in Bernoulli numbers
-691//2730

julia&gt; bernoulli(50) # and they grow fairly fast
495057205241079648212477525//66</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1946-L1967">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.prime_residues" href="#Combinat.prime_residues"><code>Combinat.prime_residues</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>prime_residues(n)</code> the numbers in <code>1:n</code> prime to <code>n</code></p><pre><code class="language-julia-repl hljs">julia&gt; [prime_residues(24)]
1-element Vector{Vector{Int64}}:
 [1, 5, 7, 11, 13, 17, 19, 23]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1878-L1885">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.primitiveroot" href="#Combinat.primitiveroot"><code>Combinat.primitiveroot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>primitiveroot(m::Integer)</code>   a   primitive   root,   that   is  generating multiplicatively  <code>mod.  m</code>  the  <code>prime_residues(m)</code>. The function returns <code>nothing</code> if there is no primitive root <code>mod. m</code>.</p><p>A  primitive root exists if <code>m</code> is equal to <code>4</code> or <code>p^a</code> or <code>2p^a</code> for <code>p</code> prime&gt;2.</p><pre><code class="language-julia-repl hljs">julia&gt; primitiveroot(23)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1895-L1907">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Combinat.moebius" href="#Combinat.moebius"><code>Combinat.moebius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>moebius(n::Integer)</code></p><p>The  classical  Möbius  function  is  the  Möbius  function of the poset of integers for divisibility. It is zero outside square-free integers, and for square-free integers is `(-1)ⁿ&#39; where n is the number of prime factors.</p><pre><code class="language-julia-repl hljs">julia&gt; moebius.(1:6)
6-element Vector{Int64}:
  1
 -1
 -1
  0
 -1
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Combinat.jl/blob/fc8bd47b644adcfa2e3f3976b83c2a3a12acae72/src/Combinat.jl#L1922-L1938">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Monday 10 November 2025 18:02">Monday 10 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
