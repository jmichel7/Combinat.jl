var documenterSearchIndex = {"docs":
[{"location":"#Combinat","page":"Home","title":"Combinat","text":"Documentation for Combinat.","category":"section"},{"location":"#Combinat.Combinat","page":"Home","title":"Combinat.Combinat","text":"This  module  started  as  a  Julia  port of combinatorics and basic number theory  functions  from  GAP.  See  comments  below  on  how it compares to Combinatorics.jl. The only dependency is the Primes package.\n\nThe list of functions it exports are:\n\nClassical enumerations:\n\ncombinations, arrangements, permutations, partitions, compositions, partition_tuples, multisets\n\nthe  first five of them  are implemented by iterators,  which have the same name but capitalized. This allows to do itemwise computations on very large enumerations without allocating memory:\n\nCombinations, Arrangements, Permutations, Partitions, Compositions,\n\nfunctions to count enumerations without computing them:\n\nncombinations, narrangements, npermutations, npartitions, ncompositions, npartition_tuples, nmultisets\n\nsome functions on partitions and tableaux:\n\nlcm_partitions, gcd_partitions, conjugate_partition, dominates, tableaux, semistandard_tableaux, robinson_schensted\n\ncounting functions:\n\nbell, stirling1, stirling2, catalan, bernoulli\n\nnumber theory\n\nprime_residues, primitiveroot, moebius\n\nsome structural manipulations not (yet?) in Julia:\n\ngroupby, tally, tally_sorted, collectby, unique_sorted!, union_sorted, intersect_sorted, symdiff_sorted\n\nmatrix blocks:\n\nblocks, diagblocks\n\nHave  a  look  at  the  individual  docstrings  and  enjoy (any feedback is welcome).  \n\nAfter  writing  most  of  this  module,  I  became  aware  of  the  package Combinatorics  which has a  considerable overlap. However  there are some discrepancies  between these  two packages  which make  Combinatorics not a suitable replacement:\n\nI often  use sorting  in algorithms  where Combinatorics uses hashing. So  the algorithms do  not always apply  to the same  types (sorting is often  faster). For  some algorithms,  I have  a keyword which lets you choose  a hashing variant. Here  hashable refers to a  type which has a hash method and sortable to a type which has an isless method.\nCombinatorics.combinations does not include the empty subset.\nI use lower  case for functions  that return enumerations  as a list and camel  case  for  iterators.  Many  enumerations  have  both  variants. Combinatorics has only one variant for enumerations, which is often a lowercase iterator.\nCombinatorics has fewer enumerations.\n\nA    less   fundamental   discrepancy   concerns   names.   For   instance, Combinatorics.multiset_combinations   and   Combinatorics.powerset  are cases   of  Combinat.combinations;  Combinatorics.multiexponents  is  a special case of Combinat.compositions; Combinatorics.integer_partitions is  a case  of Combinat.partitions; Combinatorics.multiset_permutations is Combinat.arrangements. I would welcome discussions with the authors of Combinatorics to see if the two packages could be made more compatible in this respect.\n\n\n\n\n\n","category":"module"},{"location":"#Combinat.combinations","page":"Home","title":"Combinat.combinations","text":"combinations(mset[,k];dict=false),  ncombinations(mset[,k];dict=false)\n\ncombinations   returns  all  combinations  of   the  multiset  mset  (a collection  or  iterable  with  possible  repetitions). If a second integer argument  k is given, it returns  the combinations with k elements. k may  also be a vector  of integers, then it  returns the combinations whose number of elements is one of these integers.\n\nncombinations returns (faster) the number of combinations.\n\nA  combination is an unordered subsequence.\n\nBy  default, the elements of mset  are assumed sortable and a combination is  represented by a sorted Vector.  The combinations with a fixed number k  of  elements  are  listed  in  lexicographic order. If the elements of mset  are not sortable but hashable, the keyword dict=true can be given and the (slightly slower) computation is done using a Dict.\n\nIf  mset has  no repetitions,  the list  of all  combinations is just the powerset of mset.\n\njulia> ncombinations([1,2,2,3])\n12\n\njulia> combinations([1,2,2,3])\n12-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [3]\n [1, 2]\n [1, 3]\n [2, 2]\n [2, 3]\n [1, 2, 2]\n [1, 2, 3]\n [2, 2, 3]\n [1, 2, 2, 3]\n\nThe  combinations  are  implemented  by  an iterator Combinations which can enumerate the combinations of a large multiset.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.Combinations","page":"Home","title":"Combinat.Combinations","text":"Combinations(s[,k];dict=false)  is an  iterator which enumerates the  combinations of  the multiset  s (with  k elements if kgiven) in lexicographic order. The elements of s must be sortable. If they are not, but  hashable, giving the  keyword dict=true will  give an iterator which enumerates the combinations in an unspecified order.\n\njulia> a=Combinations(1:4);\n\njulia> collect(a)\n16-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [3]\n [4]\n [1, 2]\n [1, 3]\n [1, 4]\n [2, 3]\n [2, 4]\n [3, 4]\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n [1, 2, 3, 4]\n\njulia> a=Combinations([1,2,2,3,4,4],3)\nCombinations([1, 2, 2, 3, 4, 4],3)\n\njulia> collect(a)\n10-element Vector{Vector{Int64}}:\n [1, 2, 2]\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 4]\n [1, 4, 4]\n [2, 2, 3]\n [2, 2, 4]\n [2, 3, 4]\n [2, 4, 4]\n [3, 4, 4]\n\n\n\n\n\n","category":"type"},{"location":"#Combinat.arrangements","page":"Home","title":"Combinat.arrangements","text":"arrangements(mset[,k]), narrangements(mset[,k])\n\narrangements  returns  the  arrangements  of  the  multiset mset (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument   k  is  given,  it  returns  arrangements  with  k  elements. narrangements returns (faster) the number of arrangements.\n\nAn arrangement of mset with k elements is a subsequence of length k taken in arbitrary order, representated as a Vector. When k==length(mset) it is also called a permutation.\n\nAs  an example of arrangements  of a multiset, think  of the game Scrabble. Suppose  you have the six  characters of the word  'settle' and you have to make a two letter word. Then the possibilities are given by\n\njulia> narrangements(\"settle\",2)\n14\n\nwhile all possible words (including the empty one) are:\n\njulia> narrangements(\"settle\")\n523\n\nHere are the two-letter words:\n\njulia> String.(arrangements(\"settle\",2))\n14-element Vector{String}:\n \"ee\"\n \"el\"\n \"le\"\n \"es\"\n \"se\"\n \"et\"\n \"te\"\n \"ls\"\n \"sl\"\n \"lt\"\n \"tl\"\n \"st\"\n \"ts\"\n \"tt\"\n\nThe  arrangements are implemented  by an iterator  Arrangements which can enumerate the arrangements of a large multiset.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.Arrangements","page":"Home","title":"Combinat.Arrangements","text":"Arrangements is an iterator for arrangements\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.permutations","page":"Home","title":"Combinat.permutations","text":"permutations(v::AbstractVector), permutations(n::Int), npermutations\n\nin  the first  form, the  elements of  v must  be sortable.  The function returns  in lexicographic  order the  distinct permutations  of the  set or multiset v.  This   is  the  same   as  arrangements(v,length(v)).  \n\nThe second form is the same as permutations(1:n).\n\npermutations is implemented by an iterator Permutations.\n\nnpermutations counts the permutations (fast) without computing them.\n\njulia> permutations(3)\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\njulia> sum(first(p) for p in Permutations(5))\n360\n\njulia> permutations([:b,:b,:a,:a])\n6-element Vector{Vector{Symbol}}:\n [:a, :a, :b, :b]\n [:a, :b, :a, :b]\n [:a, :b, :b, :a]\n [:b, :a, :a, :b]\n [:b, :a, :b, :a]\n [:b, :b, :a, :a]\n \njulia> npermutations([:b,:b,:a,:a])\n6\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.Permutations","page":"Home","title":"Combinat.Permutations","text":"Permutations is an iterator for permutations\n\n\n\n\n\n","category":"type"},{"location":"#Combinat.partitions","page":"Home","title":"Combinat.partitions","text":"partitions(n::Integer[,k]), npartitions(n::Integer[,k])\n\npartitions  returns in lexicographic order the partitions (with k parts if  k  is  given)  of  the  positive  integer n . npartitions returns (faster) the number of partitions.\n\nThere are approximately exp(π√(2n/3))/(4√3 n) partitions of n.\n\nA   partition  is   a  decomposition   n=p₁+p₂+…+pₖ  in  integers  with p₁≥p₂≥…≥pₖ>0, and is represented by the vector p=[p₁,p₂,…,pₖ]. We write p⊢n to say that p is a partition of n.\n\njulia> npartitions(7)\n15\n\njulia> partitions(7)\n15-element Vector{Vector{Int64}}:\n [1, 1, 1, 1, 1, 1, 1]\n [2, 1, 1, 1, 1, 1]\n [2, 2, 1, 1, 1]\n [2, 2, 2, 1]\n [3, 1, 1, 1, 1]\n [3, 2, 1, 1]\n [3, 2, 2]\n [3, 3, 1]\n [4, 1, 1, 1]\n [4, 2, 1]\n [4, 3]\n [5, 1, 1]\n [5, 2]\n [6, 1]\n [7]\n\njulia> npartitions(7,3)\n4\n\njulia> partitions(7,3)\n4-element Vector{Vector{Int64}}:\n [3, 2, 2]\n [3, 3, 1]\n [4, 2, 1]\n [5, 1, 1]\n\nThe  partitions are implemented by an iterator Partitions(n[,k]) which can be used to enumerate the partitions of a large number.\n\n\n\n\n\npartitions(n::Integer,set::AbstractVector[,k]), npartitions(n::Integer,set::AbstractVector[,k])   \n\nreturns  the list  of partitions  of n  (with k  parts if k is given) restricted  to have parts in set. npartitions gives (faster) the number of such partitions.\n\nLet  us show how many ways there are to pay 17 cents using coins of 2,5 and 10 cents.\n\njulia> npartitions(17,[10,5,2])\n3\n\njulia> partitions(17,[10,5,2])\n3-element Vector{Vector{Int64}}:\n [5, 2, 2, 2, 2, 2, 2]\n [5, 5, 5, 2]\n [10, 5, 2]\n\njulia> npartitions(17,[10,5,2],3) # pay with 3 coins\n1\n\njulia> partitions(17,[10,5,2],3) \n1-element Vector{Vector{Int64}}:\n [10, 5, 2]\n\n\n\n\n\npartitions(set::AbstractVector[,k]), npartitions(set::AbstractVector[,k])\n\nthe  set of all unordered  partitions (in k sets  if k is given) of the set  set (a  collection without  repetitions). npartitions  returns the number of unordered partitions.\n\nAn unordered partition of set is a set of pairwise disjoints sets whose union is equal to set, and is represented by a Vector of Vectors.\n\njulia> npartitions(1:3)\n5\n\njulia> partitions(1:3)\n5-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3]]\n [[1, 2], [3]]\n [[1, 3], [2]]\n [[1], [2, 3]]\n [[1], [2], [3]]\n\njulia> npartitions(1:4,2)\n7\n\njulia> partitions(1:4,2)\n7-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [4]]\n [[1, 2, 4], [3]]\n [[1, 2], [3, 4]]\n [[1, 3, 4], [2]]\n [[1, 3], [2, 4]]\n [[1, 4], [2, 3]]\n [[1], [2, 3, 4]]\n\nNote  that unique(sort.(partitions(mset[,k])))  is a  version which works for a multiset mset.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.Partitions","page":"Home","title":"Combinat.Partitions","text":"Partitions(n[,k]) is an iterator which enumerates the partitions of n (with k parts if kgiven) in lexicographic order.\n\njulia> a=Partitions(5)\nPartitions(5)\n\njulia> collect(a)\n7-element Vector{Vector{Int64}}:\n [1, 1, 1, 1, 1]\n [2, 1, 1, 1]\n [2, 2, 1]\n [3, 1, 1]\n [3, 2]\n [4, 1]\n [5]\n\njulia> a=Partitions(10,3)\nPartitions(10,3)\n\njulia> collect(a)\n8-element Vector{Vector{Int64}}:\n [4, 3, 3]\n [4, 4, 2]\n [5, 3, 2]\n [5, 4, 1]\n [6, 2, 2]\n [6, 3, 1]\n [7, 2, 1]\n [8, 1, 1]\n\n\n\n\n\n","category":"type"},{"location":"#Combinat.partition_tuples","page":"Home","title":"Combinat.partition_tuples","text":"partition_tuples(n,r), npartition_tuples(n,r)\n\nthe r-tuples of partitions that together partition n. npartition_tuples is the number of partition tuples.\n\njulia> npartition_tuples(3,2)\n10\n\njulia> partition_tuples(3,2)\n10-element Vector{Vector{Vector{Int64}}}:\n [[1, 1, 1], []]\n [[1, 1], [1]]\n [[1], [1, 1]]\n [[], [1, 1, 1]]\n [[2, 1], []]\n [[1], [2]]\n [[2], [1]]\n [[], [2, 1]]\n [[3], []]\n [[], [3]]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.compositions","page":"Home","title":"Combinat.compositions","text":"compositions(n[,k];min=1), ncompositions(n[,k];min=1)\n\nThis  function returns the compositions of  n (the compositions of length k  if a second argument k is given), where a composition of the integer n  is a decomposition n=p₁+…+pₖ in  integers ≥min, represented as the vector  [p₁,…,pₖ]. Unless k is given,  min must be >0. Compositions are sometimes called ordered partitions.\n\nncompositions  returns  (faster)  the  number  of compositions. There are 2^n-1  compositions of n in  integers ≥1, and binomial(n-1,k-1) compositions of n in k parts ≥1.\n\njulia> ncompositions(4)\n8\n\njulia> compositions(4)\n8-element Vector{Vector{Int64}}:\n [4]\n [1, 3]\n [2, 2]\n [3, 1]\n [1, 1, 2]\n [1, 2, 1]\n [2, 1, 1]\n [1, 1, 1, 1]\n\njulia> ncompositions(4,2)\n3\n\njulia> compositions(4,2)\n3-element Vector{Vector{Int64}}:\n [1, 3]\n [2, 2]\n [3, 1]\n\njulia> ncompositions(4,2;min=0)\n5\n\njulia> compositions(4,2;min=0)\n5-element Vector{Vector{Int64}}:\n [0, 4]\n [1, 3]\n [2, 2]\n [3, 1]\n [4, 0]\n\nThe compositions are implemented by an iterator Compositions(n[,k];min=1) which can be used to enumerate the compositions of a large number.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.Compositions","page":"Home","title":"Combinat.Compositions","text":"Compositions is an iterator for compositions\n\n\n\n\n\n","category":"type"},{"location":"#Combinat.multisets","page":"Home","title":"Combinat.multisets","text":"multisets(set,k), nmultisets(set,k)\n\nmultisets  returns  the  set  of  all  multisets of length k made of elements   of   the   set   set   (a   collection  without  repetitions). nmultisets returns the number of multisets.\n\nAn  multiset of length k is  an unordered selection with repetitions of length  k from set and is represented  by a sorted vector of length k made  of elements  from set  (it is  also sometimes called a \"combination with replacement\").\n\njulia> multisets(1:4,3)\n20-element Vector{Vector{Int64}}:\n [1, 1, 1]\n [1, 1, 2]\n [1, 1, 3]\n [1, 1, 4]\n [1, 2, 2]\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 3]\n [1, 3, 4]\n [1, 4, 4]\n [2, 2, 2]\n [2, 2, 3]\n [2, 2, 4]\n [2, 3, 3]\n [2, 3, 4]\n [2, 4, 4]\n [3, 3, 3]\n [3, 3, 4]\n [3, 4, 4]\n [4, 4, 4]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.lcm_partitions","page":"Home","title":"Combinat.lcm_partitions","text":"lcm_partitions(p1,…,pn)\n\neach  argument is  a partition  of the  same set  S, given  as a  list of disjoint  vectors whose  union is  S. Equivalently  each argument  can be interpreted as an equivalence relation on S.\n\nThe result is the finest partition of S such that each argument partition refines it. It represents the 'or' of the equivalence relations represented by the arguments.\n\njulia> lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])\n2-element Vector{Vector{Int64}}:\n [1, 2, 5, 6]\n [3, 4]      \n\n\n\n\n\n","category":"function"},{"location":"#Combinat.gcd_partitions","page":"Home","title":"Combinat.gcd_partitions","text":"gcd_partitions(p1,…,pn)\n\nEach  argument is  a partition  of the  same set  S, given  as a  list of disjoint  vectors whose  union is  S. Equivalently  each argument  can be interpreted as an equivalence relation on S.\n\nThe result is the coarsest partition which refines all argument partitions. It  represents the  'and' of  the equivalence  relations represented by the arguments.\n\njulia> gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])\n6-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.conjugate_partition","page":"Home","title":"Combinat.conjugate_partition","text":"conjugate_partition(λ)\n\nreturns  the  conjugate  partition  of  the  partition  λ,  that  is, the partition having the transposed of the Young diagram of λ.\n\njulia> conjugate_partition([4,2,1])\n4-element Vector{Int64}:\n 3\n 2\n 1\n 1\n\njulia> conjugate_partition([6])\n6-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.dominates","page":"Home","title":"Combinat.dominates","text":"dominates(λ,μ)\n\nThe  dominance  order  on  partitions  is  an  important  partial  order in representation theory. λ dominates μ if and only if for all i we have sum(λ[1:i])≥sum(μ[1:i]).\n\njulia> dominates([5,4],[4,4,1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.tableaux","page":"Home","title":"Combinat.tableaux","text":"tableaux(S)\n\nif  S  is  a  partition  tuple,  returns  the  list  of standard tableaux associated  with  the  partition  tuple  S,  that  is  a  filling  of the associated  young diagrams  with the  numbers 1:sum(sum,S)  such that the numbers increase across the rows and down the columns.\n\nIf  S is a single partition, the standard tableaux for that partition are returned.\n\njulia> tableaux([[2,1],[1]])\n8-element Vector{Vector{Vector{Vector{Int64}}}}:\n [[[1, 2], [3]], [[4]]]\n [[[1, 2], [4]], [[3]]]\n [[[1, 3], [2]], [[4]]]\n [[[1, 3], [4]], [[2]]]\n [[[1, 4], [2]], [[3]]]\n [[[1, 4], [3]], [[2]]]\n [[[2, 3], [4]], [[1]]]\n [[[2, 4], [3]], [[1]]]\n\njulia> tableaux([2,2])\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2], [3, 4]]\n [[1, 3], [2, 4]]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.semistandard_tableaux","page":"Home","title":"Combinat.semistandard_tableaux","text":"semistandard_tableaux(λ,c)\n\nc  should be  a non-decreasing  list and  λ a partition of length(c). Returns  the list of semi_standard tableaux with shape λ and content c, that is a filling of the young diagram of λ with the elements of c such that they increase down the columns and do not decrease across the rows.\n\njulia> semistandard_tableaux([3,2,1],[1,2,2,3,4,5])\n8-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 2], [3, 4], [5]]\n [[1, 2, 2], [3, 5], [4]]\n [[1, 2, 3], [2, 4], [5]]\n [[1, 2, 3], [2, 5], [4]]\n [[1, 2, 4], [2, 3], [5]]\n [[1, 2, 5], [2, 3], [4]]\n [[1, 2, 4], [2, 5], [3]]\n [[1, 2, 5], [2, 4], [3]]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.robinson_schensted","page":"Home","title":"Combinat.robinson_schensted","text":"robinson_schensted(p::AbstractVector{<:Integer})\n\nreturns  the pair of standard tableaux  associated with the permutation p by the Robinson-Schensted correspondence.\n\njulia> robinson_schensted([2,3,4,1])\n([[1, 3, 4], [2]], [[1, 2, 3], [4]])\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.bell","page":"Home","title":"Combinat.bell","text":"'bell(n)'\n\nThe  Bell numbers are  defined by bell(0)=1  and bell(n+1)=_k=0^n n choose  kbell(k), or by the fact  that bell(n)/n! is the coefficient of xⁿ in the formal series e^(eˣ-1).\n\njulia> bell.(0:6)\n7-element Vector{Int64}:\n   1\n   1\n   2\n   5\n  15\n  52\n 203\n\njulia> bell(14)\n190899322\n\njulia> bell(big(30))\n846749014511809332450147\n\nAlso, bell(n) is the number of unordered partitions of a set of size n.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.stirling1","page":"Home","title":"Combinat.stirling1","text":"stirling1(n,k)\n\nthe  Stirling  numbers  of  the  first  kind  S₁(n,k)  are  defined  by S₁(0,0)=1,   S₁(n,0)=S₁(0,k)=0   if   n,   k!=0   and   the  recurrence S₁(n,k)=(n-1)S₁(n-1,k)+S₁(n-1,k-1).\n\nS₁(n,k)  is the  number of  permutations of  n points  with k cycles. They   are   also   given   by   the   generating  function  nxchoose n=sum_k=0^n(S₁(nk) x^k). Note the similarity to x^n=sum_k=0^n S₂(nk)kxchoose k (see  stirling2).  Also  the  definition of S₁ implies  S₁(n,k)=S₂(-k,-n) if  n,k<0. There  are many formulae relating Stirling  numbers of the first kind to Stirling numbers of the second kind, Bell numbers, and Binomial numbers.\n\njulia> stirling1.(4,0:4) # Knuth calls this the trademark of S₁\n5-element Vector{Int64}:\n  0\n  6\n 11\n  6\n  1\n\njulia> [stirling1(n,k) for n in 0:6, k in 0:6] # similar to Pascal's triangle\n7×7 Matrix{Int64}:\n 1    0    0    0   0   0  0\n 0    1    0    0   0   0  0\n 0    1    1    0   0   0  0\n 0    2    3    1   0   0  0\n 0    6   11    6   1   0  0\n 0   24   50   35  10   1  0\n 0  120  274  225  85  15  1\n\njulia> stirling1(50,big(10)) # give `big` second argument to avoid overflow\n101623020926367490059043797119309944043405505380503665627365376\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.stirling2","page":"Home","title":"Combinat.stirling2","text":"stirling2(n,k)\n\nthe  Stirling  numbers  of  the  second  kind are defined by S₂(0,0)=1, S₂(n,0)=S₂(0,k)=0 if n, k!=0 and S₂(n,k)=k S₂(n-1,k)+S₂(n-1,k-1), and also as coefficients of the generating function x^n=sum_k=0^nS₂(nk) kxchoose k.\n\njulia> stirling2.(4,0:4)  # Knuth calls this the trademark of S₂\n5-element Vector{Int64}:\n 0\n 1\n 7\n 6\n 1\n\njulia> [stirling2(i,j) for i in 0:6, j in 0:6] # similar to Pascal's triangle\n7×7 Matrix{Int64}:\n 1  0   0   0   0   0  0 \n 0  1   0   0   0   0  0\n 0  1   1   0   0   0  0\n 0  1   3   1   0   0  0\n 0  1   7   6   1   0  0\n 0  1  15  25  10   1  0\n 0  1  31  90  65  15  1\n\njulia> stirling2(50,big(10)) # give `big` second argument to avoid overflow\n26154716515862881292012777396577993781727011\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.catalan-Tuple{Integer}","page":"Home","title":"Combinat.catalan","text":"Catalan(n) n-th Catalan Number\n\njulia> catalan(8)\n1430\n\njulia> catalan(big(50))\n1978261657756160653623774456\n\n\n\n\n\n","category":"method"},{"location":"#Combinat.bernoulli","page":"Home","title":"Combinat.bernoulli","text":"bernoulli(n) the n-th Bernoulli number  Bₙ as a Rational{BigInt}\n\nBₙ    is    defined    by   B₀=1   B_n=-sum_k=0^n-1(n+1choose kB_k)(n+1).  Bₙ/n! is the coefficient of  xⁿ in the power series of x/(eˣ-1).  Except for B₁=-1/2 the Bernoulli numbers for odd indices are zero.\n\njulia> bernoulli(4)\n-1//30\n\njulia> bernoulli(10)\n5//66\n\njulia> bernoulli(12) # there is no simple pattern in Bernoulli numbers\n-691//2730\n\njulia> bernoulli(50) # and they grow fairly fast\n495057205241079648212477525//66\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.prime_residues","page":"Home","title":"Combinat.prime_residues","text":"prime_residues(n) the numbers in 1:n prime to n\n\njulia> [prime_residues(24)]\n1-element Vector{Vector{Int64}}:\n [1, 5, 7, 11, 13, 17, 19, 23]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.primitiveroot","page":"Home","title":"Combinat.primitiveroot","text":"primitiveroot(m::Integer)   a   primitive   root,   that   is  generating multiplicatively  mod.  m  the  prime_residues(m). The function returns nothing if there is no primitive root mod. m.\n\nA  primitive root exists if m is equal to 4 or p^a or 2p^a for p prime>2.\n\njulia> primitiveroot(23)\n5\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.moebius","page":"Home","title":"Combinat.moebius","text":"moebius(n::Integer)\n\nThe  classical  Möbius  function  is  the  Möbius  function of the poset of integers for divisibility. It is zero outside square-free integers, and for square-free integers is (-1)ⁿ where n is the number of prime factors.\n\njulia> moebius.(1:6)\n6-element Vector{Int64}:\n  1\n -1\n -1\n  0\n -1\n  1\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.groupby","page":"Home","title":"Combinat.groupby","text":"groupby(v,l)\n\nreturn  a  Dict  grouping  elements  of  collection  l according to the corresponding  values in the collection v,  which should have same length as l, and whose elements must be hashable.\n\njulia> groupby([31,28,31,30,31,30,31,31,30,31,30,31],\n  [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])\nDict{Int64,Vector{Symbol}} with 3 entries:\n  31 => Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]\n  28 => Symbol[:Feb]\n  30 => Symbol[:Apr, :Jun, :Sep, :Nov]\n\n\n\n\n\ngroupby(f::Function,l)\n\nreturn a Dict grouping elements of collection l according to the values taken by function f on them. The values of f must be hashable.\n\njulia> groupby(iseven,1:10)\nDict{Bool, Vector{Int64}} with 2 entries:\n  0 => [1, 3, 5, 7, 9]\n  1 => [2, 4, 6, 8, 10]\n\nNote:  keys of the result will  have type Any if l  is empty since I do not know how to access the return type of a function\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.tally","page":"Home","title":"Combinat.tally","text":"tally(v;dict=false)\n\ncounts how many times each element of collection or iterable v occurs and returns a sorted Vector of elt=>count (a variant of StatsBase.countmap).  By default the  elements of v  must be sortable; if they  are not but hashable, giving the keyword dict=true uses a Dict to build (much slower) an unsorted result.\n\njulia> tally(\"a tally test\")\n7-element Vector{Pair{Char, Int64}}:\n ' ' => 2\n 'a' => 2\n 'e' => 1\n 'l' => 2\n 's' => 1\n 't' => 3\n 'y' => 1\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.tally_sorted","page":"Home","title":"Combinat.tally_sorted","text":"tally_sorted(v)\n\ntally_sorted  is like tally  but works only  for a sorted iterable. The point is that it is very fast.\n\njulia> tally_sorted(\"aabbbeee\")\n3-element Vector{Pair{Char, Int64}}:\n 'a' => 2\n 'b' => 3\n 'e' => 3\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.collectby","page":"Home","title":"Combinat.collectby","text":"collectby(f,v)\n\ngroup  the elements of v in packets  (Vectors) where f takes the same value.  The resulting Vector{Vector} is sorted  by the values of f (the values  of  f  must  be  sortable;  otherwise  you  can  use  the  slower values(groupby(f,v))).  Here f can  be a function  of one variable or a collection of same length as v.\n\njulia> l=[:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec];\n\njulia> collectby(x->first(string(x)),l)\n8-element Vector{Vector{Symbol}}:\n [:Apr, :Aug]\n [:Dec]\n [:Feb]\n [:Jan, :Jun, :Jul]\n [:Mar, :May]\n [:Nov]\n [:Oct]\n [:Sep]\n\njulia> collectby(\"JFMAMJJASOND\",l)\n8-element Vector{Vector{Symbol}}:\n [:Apr, :Aug]\n [:Dec]\n [:Feb]\n [:Jan, :Jun, :Jul]\n [:Mar, :May]\n [:Nov]\n [:Oct]\n [:Sep]\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.unique_sorted!","page":"Home","title":"Combinat.unique_sorted!","text":"unique_sorted!(v::Vector) many times faster than unique! for sorted v\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.intersect_sorted","page":"Home","title":"Combinat.intersect_sorted","text":"intersect_sorted(a,b) \n\nintersects   a  and   b  assumed   to  be   both  sorted   and  without repetitions(and  their elements sortable).  This is many  times faster than intersect.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.symdiff_sorted","page":"Home","title":"Combinat.symdiff_sorted","text":"symdiff_sorted(a,b) \n\ncomputes  the symmetric difference of a and b assumed to be both sorted and  without  repetitions  (and  their  elements  sortable).  The result is sorted,  so may differ  from symdiff; this  function is many times faster than symdiff.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.union_sorted","page":"Home","title":"Combinat.union_sorted","text":"union_sorted(a,b) \n\ncomputes  the union of  a and b  assumed to be  both sorted and without repetitions  (and their  elements sortable).  The result  is sorted, so may differ from union; this function is many times faster than union.\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.diagblocks","page":"Home","title":"Combinat.diagblocks","text":"diagblocks(M::Matrix)\n\nM  should  be  a  square  matrix.  Define  a  graph  G  with vertices 1:size(M,1) and with an edge between i  and j if either M[i,j] or M[j,i] is not zero or false. diagblocks returns a vector of vectors I  such that  I[1],I[2], etc..  are the  vertices in each connected component  of G.  In other  words, M[I[1],I[1]],M[I[2],I[2]],etc... are diagonal blocks of M.\n\njulia> m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]\n4×4 Matrix{Int64}:\n 0  0  0  1\n 0  0  1  0\n 0  1  0  0\n 1  0  0  0\n\njulia> diagblocks(m)\n2-element Vector{Vector{Int64}}:\n [1, 4]\n [2, 3]\n\njulia> m[[1,4,2,3],[1,4,2,3]]\n4×4 Matrix{Int64}:\n 0  1  0  0\n 1  0  0  0\n 0  0  0  1\n 0  0  1  0\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.blocks-Tuple{AbstractMatrix}","page":"Home","title":"Combinat.blocks","text":"blocks(M:AbstractMatrix)\n\nFinds  if the  matrix  M admits a block decomposition.\n\nDefine  a bipartite  graph G  with vertices  axes(M,1), axes(M,2) and with an edge between i and j if M[i,j] is not zero. BlocksMat returns a  list of pairs of  lists I such that  I[i], etc.. are the vertices in the i-th connected component of G. In other words, M[I[1][1],I[1][2]], M[I[2][1],I[2][2]],etc... are blocks of M.\n\nThis  function may  also be  applied to  boolean matrices.\n\njulia> m=[1 0 0 0;0 1 0 0;1 0 1 0;0 0 0 1;0 0 1 0]\n5×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 1  0  1  0\n 0  0  0  1\n 0  0  1  0\n\njulia> blocks(m)\n3-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:\n ([1, 3, 5], [1, 3])\n ([2], [2])\n ([4], [4])\n\njulia> m[[1,3,5,2,4],[1,3,2,4]]\n5×4 Matrix{Int64}:\n 1  0  0  0\n 1  1  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\n\n\n\n\n","category":"method"}]
}
